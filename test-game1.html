<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>3x3 真正拼圖</title>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #f0f0f0;
    margin: 0;
    user-select: none;
    touch-action: none;
  }
  #puzzle {
    position: relative;
    width: 300px;
    height: 300px;
    border: 2px solid #333;
    background: #fff;
  }
  .piece {
    position: absolute;
    cursor: grab;
    touch-action: none;
    transition: transform 0.2s;
  }
</style>
</head>
<body>

<div id="puzzle"></div>

<script>
const PUZZLE_SIZE = 300;
const ROWS = 3;
const COLS = 3;
const pieceSize = PUZZLE_SIZE / ROWS;
const puzzle = document.getElementById('puzzle');

// 圖片來源
const imgSrc = 'https://picsum.photos/300/300'; // 可換成你想要的圖片

// 生成拼圖
function createPuzzle(img) {
  const pieces = [];
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const canvas = document.createElement('canvas');
      canvas.width = pieceSize;
      canvas.height = pieceSize;
      canvas.classList.add('piece');
      canvas.dataset.row = r;
      canvas.dataset.col = c;

      const ctx = canvas.getContext('2d');

      // 先填背景透明
      ctx.clearRect(0,0,pieceSize,pieceSize);

      // 畫拼圖形狀（簡單凸凹示意）
      ctx.beginPath();
      const ear = pieceSize/4;
      if(r>0) ctx.moveTo(0, ear);
      else ctx.moveTo(0,0);
      ctx.lineTo(pieceSize,0);
      ctx.lineTo(pieceSize, pieceSize);
      ctx.lineTo(0,pieceSize);
      ctx.closePath();
      ctx.clip();

      ctx.drawImage(
        img,
        c*pieceSize, r*pieceSize, pieceSize, pieceSize,
        0,0,pieceSize,pieceSize
      );

      // 初始隨機位置
      canvas.style.left = Math.random()*(PUZZLE_SIZE-pieceSize)+'px';
      canvas.style.top = Math.random()*(PUZZLE_SIZE-pieceSize)+'px';

      puzzle.appendChild(canvas);
      pieces.push(canvas);
    }
  }
  makeDraggable(pieces);
}

// 拖拉功能
function makeDraggable(pieces){
  let dragging = null;
  let offsetX = 0;
  let offsetY = 0;

  pieces.forEach(piece => {
    piece.addEventListener('pointerdown', e=>{
      dragging = piece;
      offsetX = e.clientX - piece.offsetLeft;
      offsetY = e.clientY - piece.offsetTop;
      piece.style.zIndex = 1000;
      piece.setPointerCapture(e.pointerId);
    });

    piece.addEventListener('pointermove', e=>{
      if(!dragging) return;
      let x = e.clientX - offsetX;
      let y = e.clientY - offsetY;
      dragging.style.left = x + 'px';
      dragging.style.top = y + 'px';
    });

    piece.addEventListener('pointerup', e=>{
      if(!dragging) return;
      // 吸附到格子
      const row = parseInt(dragging.dataset.row);
      const col = parseInt(dragging.dataset.col);
      const targetX = col * pieceSize;
      const targetY = row * pieceSize;
      const dx = dragging.offsetLeft - targetX;
      const dy = dragging.offsetTop - targetY;
      if(Math.hypot(dx, dy) < pieceSize/2){
        dragging.style.left = targetX+'px';
        dragging.style.top = targetY+'px';
      }
      dragging.style.zIndex = 1;
      dragging.releasePointerCapture(e.pointerId);
      dragging = null;
      checkWin(pieces);
    });
  });
}

// 判斷完成
function checkWin(pieces){
  const completed = pieces.every(p=>{
    const row = parseInt(p.dataset.row);
    const col = parseInt(p.dataset.col);
    return parseInt(p.style.left) === col*pieceSize && parseInt(p.style.top) === row*pieceSize;
  });
  if(completed){
    setTimeout(()=>alert('恭喜完成拼圖！'), 100);
  }
}

// 載入圖片後建立拼圖
const img = new Image();
img.crossOrigin = "Anonymous";
img.src = imgSrc;
img.onload = ()=> createPuzzle(img);
</script>

</body>
</html>
